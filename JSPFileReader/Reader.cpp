#include "Reader.h"
#include<qfile.h>
#include<qdatastream.h>
#include<qdebug.h>

Reader::Reader(QObject *parent)
	: QThread(parent)
{}

void Reader::run()
{

	/*
	No funciona el checksum (el método)
	*/

	file = new QFile("//srv01/PracticasProgramacion/Datos/Kalman/20160809_141551.JPS");
	
	crc16init();
	
	if (file->open(QIODevice::ReadOnly)) 
	{
		char *type1 = new char[1];
		char *type2 = new char[1];
		
		in = new QDataStream(file);
		in->setByteOrder(QDataStream::LittleEndian);
		
		while (!in->atEnd())
		{
			in->readRawData(type1, 1);
			in->readRawData(type2, 1);
		
			if((*type1 == 'N') && (*type2 == 'P'))
			{
				int pos = file->pos();
				int goBack = pos+4;
				
				/*QByteArray size(3,'0');
				in->readRawData(size.data(), 3);
				
				bool ok;
				size.toInt(&ok,16);*/


				char *size1 = new char[1];
				char *size2 = new char[1];
				char *size3 = new char[1];

				in->readRawData(size1, 1);
				in->readRawData(size2, 1);
				in->readRawData(size3, 1);

				QChar csize1(*size1);
				QChar csize2(*size2);
				QChar csize3(*size3);

				QString strSize;
				strSize.append(csize1);
				strSize.append(csize2);
				strSize.append(csize3);
				bool ok;
				int size = strSize.toInt(&ok,16);
				//int size = calculateValue(*size1,*size2,*size3);

				pos = file->pos();
				int goForward = file->pos() + size - 3;
				file->seek(goForward);

				char *at = new char[1];
				in->readRawData(at, 1);
				if (*at == '@')
				{
					char *cs1 = new char[1];
					char *cs2 = new char[1];
					in->readRawData(cs1, 1);
					in->readRawData(cs2, 1);
					nt.cs = calculateValue(*cs1, *cs2);

					bool check = calculateChecksum();

					//if (check) 
					if(true)
					{
						file->seek(goBack);
						readPackage(file,in);
					}
				}
			}
		}
		qDebug() << file->pos() << endl;
		file->close();
	}
}


void Reader::readPackage(QFile *file, QDataStream *in)
{
	qDebug() << "Estoy leyendo el paquete";

	// Saltar hasta el marcador de válido
	int pos = file->pos() + 7;
	file->seek(pos);

	char *valid = new char[1];
	in->readRawData(valid, 1);
	if (*valid == 'V')
	{
		file->seek(file->pos() + 1);
		*in >> nt.time[1];
		*in >> nt.time[2];
		*in >> nt.time[3];
	}
	else
	{
		file->seek(file->pos() + 10);
	}

	file->seek(file->pos() + 12);

	*in >> nt.ns;
	*in >> nt.latitudeD;
	*in >> nt.latitudeM;
	*in >> nt.latitudeS;
	*in >> nt.ew;
	*in >> nt.longitudeD;
	*in >> nt.longitudeM;
	*in >> nt.longitudeS;

	nts.append(nt);
}

int Reader::calculateValue(char value1, char value2, char value3)
{
	int num1 = getValue(value1);
	int num2 = getValue(value2);
	int num3 = getValue(value3);
	return (num1 * pow(16,2)) + (num2 * 16) + num3;
}

int Reader::calculateValue(char value1, char value2)
{
	int num1 = getValue(value1);
	int num2 = getValue(value2);
	return (num1 * 16) + num2;
}

int Reader::getValue(char value) 
{
	switch (value)
	{
		case '0': return 0;
		case '1': return 1;
		case '2': return 2;
		case '3': return 3;
		case '4': return 4;
		case '5': return 5;
		case '6': return 6;
		case '7': return 7;
		case '8': return 8;
		case '9': return 9;
		case 'A': return 10;
		case 'B': return 11;
		case 'C': return 12;
		case 'D': return 13;
		case 'E': return 14;
		case 'F': return 15;
	}
	return 0;
}


bool Reader::calculateChecksum()
{
	unsigned char block[1 + 2 + 512 + 2 + 1];
	Crc16 crc = 0;
	crc = crc16(crc, block, 1 + 2 + 512);
	return (crc == nt.cs);
}

typedef unsigned short Crc16;
enum {
	WIDTH = 16, // Width of poly 
	POLY = 0x1021, // Poly. Bit #16 is set and hidden 
	BYTE_BITS = 8, // Number of bits in byte
	TABLE_SIZE = 1 << BYTE_BITS, // Size of table 
	MSB_MASK = 1 << (WIDTH - 1) // Mask for high order bit in a word 
};

//CHECKSUM de 16 bits
// Table (generated by 'crc16init()'). 
static Crc16 table[TABLE_SIZE];

// Initializes the table. Should be called once before the first 
// call to 'crc16()' 
void Reader::crc16init(void) {
	Crc16 i;
	for (i = 0; i < TABLE_SIZE; ++i) {
		Crc16 val = i << (WIDTH - BYTE_BITS);
		int j;
		for (j = 0; j < BYTE_BITS; ++j)
			val = (val << 1) ^ ((val & MSB_MASK) ? POLY : 0);
		table[i] = val;
	}
}

// Calculates CRC16 of 'cnt' bytes from 'src' and returns result. 
// Initial value of CRC16 is supplied by caller in 'crc'. 
Crc16 Reader::crc16(Crc16 crc, void const* src, int cnt)
{
	unsigned char const* s = (unsigned char const*)src;
	while (cnt--) {
		crc = (crc << BYTE_BITS) ^ table[(crc >> (WIDTH - BYTE_BITS)) ^ *s++];
	}
	return crc;
}

Reader::~Reader()
{
}