#include "Reader.h"
#include<qfile.h>
#include<qdatastream.h>
#include<qdebug.h>

Reader::Reader(QObject *parent)
	: QThread(parent)
{}

void Reader::run()
{

	/*
	No funciona el checksum (el método)
	*/

	file = new QFile("//srv01/PracticasProgramacion/Datos/Kalman/20160809_141551.JPS");
	
	crc16init();
	
	if (file->open(QIODevice::ReadOnly))
	{
		in = new QDataStream(file);
		in->setByteOrder(QDataStream::LittleEndian);

		while (!in->atEnd())
		{
			char *type1 = new char[1];
			char *type2 = new char[1];
			in->readRawData(type1, 1);
			in->readRawData(type2, 1);

			if (*type1 == 'N' && *type2 == 'P')
			{
				int goBack = file->pos() + 4;

				QByteArray strSize(3, '0');
				in->readRawData(strSize.data(), 3);
				bool ok;
				int size = strSize.toInt(&ok, 16);

				int goForward = file->pos() + size - 3;
				file->seek(goForward);

				char *at = new char[1];
				in->readRawData(at, 1);
				if (*at == '@')
				{
					QByteArray strCS(2, '0');
					in->readRawData(strCS.data(), 2);
					bool ok;
					nt.cs = strCS.toInt(&ok, 16);

					//bool check = calculateChecksum();

					bool check = cs();

					//if (check) 
					if (true)
					{
						file->seek(goBack);
						readPackage(file, in, goForward);
					}
				}
				delete at;
			}
			delete type1, type2;
		}
		qDebug() << file->pos() << endl;
		file->close();
		delete in;
	}
	delete file;
}


void Reader::readPackage(QFile *file, QDataStream *in, int goForward)
{
	//qDebug() << "Estoy leyendo el paquete";

	// Saltar hasta el marcador de válido (tamaño fijo)
	file->seek(file->pos() + 7);

	char *valid = new char[1];
	in->readRawData(valid, 1);
	file->seek(file->pos() + 1);
	
	if (*valid == 'V') 
		readTime(file, in);
	else
		goToNextField(file,in);

	for (int i = 0; i < 5; i++) goToNextField(file,in);

	readCoordinates(file, in);
	
	nts.append(nt);

	file->seek(goForward + 3);
	delete valid;
}

void Reader::readTime(QFile *file, QDataStream *in) {
	bool ok;
	QByteArray time(2, '0');

	in->readRawData(time.data(), 2);
	nt.timeHour = time.toInt(&ok, 10);

	in->readRawData(time.data(), 2);
	nt.timeMin = time.toInt(&ok, 10);

	QByteArray timeSec(5, '0');
	in->readRawData(timeSec.data(), 5);
	nt.timeSec = timeSec.toDouble();
	file->seek(file->pos() + 1);
}

void Reader::goToNextField(QFile * file, QDataStream * in)
{
	bool stop = false;
	char *next = new char[1];
	while (!stop) {
		int pos = file->pos();
		in->readRawData(next, 1);
		if (*next == ',') 
			stop = true;
	}
	delete next;
}

void Reader::readCoordinates(QFile * file, QDataStream * in)
{
	char *charNS = new char[1];
	in->readRawData(charNS, 1);
	QChar ns(*charNS);
	nt.ns = ns;

	bool ok;
	QByteArray latitude(2, '0');
	in->readRawData(latitude.data(), 2);
	nt.latitudeD = latitude.toInt(&ok, 10);

	file->seek(file->pos() + 1);

	in->readRawData(latitude.data(), 2);
	nt.latitudeM = latitude.toInt(&ok, 10);

	file->seek(file->pos() + 1);

	QByteArray latitudeSec(9, '0');
	in->readRawData(latitudeSec.data(), 9);
	nt.latitudeS = latitudeSec.toDouble();

	file->seek(file->pos() + 2);

	char *charEW = new char[1];
	in->readRawData(charEW, 1);
	QChar ew(*charEW);
	nt.ew = ew;

	QByteArray longitudeDeg(3, '0');
	in->readRawData(longitudeDeg.data(), 3);
	nt.longitudeD = longitudeDeg.toInt(&ok, 10);

	file->seek(file->pos() + 1);

	QByteArray longitudeMin(2, '0');
	in->readRawData(longitudeMin.data(), 2);
	nt.longitudeM = longitudeMin.toInt(&ok, 10);

	file->seek(file->pos() + 1);

	QByteArray longitudeSec(9, '0');
	in->readRawData(longitudeSec.data(), 9);
	nt.longitudeS = longitudeSec.toDouble();

	file->seek(file->pos() + 3);

	QByteArray altitude(10, '0');
	in->readRawData(altitude.data(), 10);
	nt.altitude = altitude.toDouble();

	delete charEW, charNS;
}

bool Reader::calculateChecksum()
{
	unsigned char block[1 + 2 + 512 + 2 + 1];
	Crc16 crc = 0;
	crc = crc16(crc, block, 1 + 2 + 512);
	return (crc == nt.cs);
}


typedef unsigned char u1;
enum {
	bits = 8,
	lShift = 2,
	rShift = bits - lShift
};

#define ROT_LEFT(val) ((val << lShift) | (val >> rShift))

u1 Reader::cs(u1 const* src, int count)
{
	u1 res = 0;
	while (count--)
		res = ROT_LEFT(res) ^ *src++;
	return ROT_LEFT(res);
}


typedef unsigned short Crc16;
enum {
	WIDTH = 16, // Width of poly 
	POLY = 0x1021, // Poly. Bit #16 is set and hidden 
	BYTE_BITS = 8, // Number of bits in byte
	TABLE_SIZE = 1 << BYTE_BITS, // Size of table 
	MSB_MASK = 1 << (WIDTH - 1) // Mask for high order bit in a word 
};

//CHECKSUM de 16 bits
// Table (generated by 'crc16init()'). 
static Crc16 table[TABLE_SIZE];

// Initializes the table. Should be called once before the first 
// call to 'crc16()' 
void Reader::crc16init(void) {
	Crc16 i;
	for (i = 0; i < TABLE_SIZE; ++i) {
		Crc16 val = i << (WIDTH - BYTE_BITS);
		int j;
		for (j = 0; j < BYTE_BITS; ++j)
			val = (val << 1) ^ ((val & MSB_MASK) ? POLY : 0);
		table[i] = val;
	}
}

// Calculates CRC16 of 'cnt' bytes from 'src' and returns result. 
// Initial value of CRC16 is supplied by caller in 'crc'. 
Crc16 Reader::crc16(Crc16 crc, void const* src, int cnt)
{
	unsigned char const* s = (unsigned char const*)src;
	while (cnt--) {
		crc = (crc << BYTE_BITS) ^ table[(crc >> (WIDTH - BYTE_BITS)) ^ *s++];
	}
	return crc;
}

Reader::~Reader()
{
}